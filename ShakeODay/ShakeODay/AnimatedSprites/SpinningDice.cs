using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using ShakeOfTheDay.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ShakeOfTheDay.AnimatedSprites
{
    public class SpinningDice : AnimatedSprite
    {
        StateManager stateManager;
        List<Vector2> imageMap = new List<Vector2>();
        public Boolean playReverse = false;
        public SpinningDice(StateManager stateManager) 
        {
            this.stateManager = stateManager;
            this.CreationTime = DateTime.Now;
            this.ID = "SpinningDiceTile";
            this.FrameColumns = 6;
            this.FrameRows = 4;
            this.LoopAnimation = true;
            this.LoopAnimationCount = 999;
            this.DisplaySize = new Vector2(102, 94);
            this.Scale = 1.5f;
            this.CreationTime = DateTime.Now;
            this.LoadContent(stateManager.contentManager);
            loadImageMap();
            this.UpdateSourceRect();


        }
        
        /// <summary>
        /// We are not using the standard layout for this tileset. Instead, I have map of the 
        /// positions for each fromae that was generated by the little tool that makes them.
        /// Since our design is pretty flexible, we can just not call base.Update, which
        /// calls its own function to update the source rectange we use to target the current tile.
        /// Instead, we will use the fixed list this generates.
        /// </summary>
        private void loadImageMap()
        {
            imageMap = new List<Vector2>() { 
                new Vector2(0, 0),
                new Vector2(103, 0),
                new Vector2(0, 95),
                new Vector2(103, 95),
                new Vector2(206, 0),
                new Vector2(206, 95),
                new Vector2(309, 0),
                new Vector2(309, 95),
                new Vector2(0, 190),
                new Vector2(0, 285),
                new Vector2(103, 190),
                new Vector2(103, 285),
                new Vector2(206, 190),
                new Vector2(206, 285),
                new Vector2(309, 190),
                new Vector2(309, 285),
                new Vector2(412, 0),
                new Vector2(412, 95),
                new Vector2(515, 0),
                new Vector2(412, 190),
                new Vector2(515, 95),
                new Vector2(412, 285),
                new Vector2(515, 190),
                new Vector2(515, 285)
            };
        }

        public override void LoadContent(ContentManager ContentManager)
        {
            base.LoadContent(ContentManager);
        }

        public override void Update(GraphicsDevice device)
        {
            TimeSpan ts = DateTime.Now - CreationTime;
            if (ts.TotalMilliseconds > 50)
            {
                CreationTime = DateTime.Now;

                if (playReverse)
                {
                    if (CurrentFrame == 0)
                    {
                        if (LoopAnimation)
                        {
                            CurrentFrame = (FrameCount - 1);

                            if (CurrentLoop > LoopAnimationCount)
                            {
                                this.IsAlive = false;
                            }

                            CurrentLoop++;
                        }
                        else
                        {
                            if (KillOnComplete)
                            {
                                this.IsAlive = false;
                            }
                        }

                    }
                    CurrentFrame--;
                }
                else
                {
                    if (CurrentFrame >= (FrameCount - 1))
                    {
                        if (LoopAnimation)
                        {
                            CurrentFrame = 0;

                            if (CurrentLoop > LoopAnimationCount)
                            {
                                this.IsAlive = false;
                            }
                            
                            CurrentLoop++;
                        }
                        else
                        {
                            if (KillOnComplete)
                            {
                                this.IsAlive = false;
                            }
                        }
                    }
                    CurrentFrame++;
                }
                
                updateSourceRect();
            }
        }

        private void updateSourceRect()
        {
            Source = new Rectangle(
                            Convert.ToInt32(imageMap[CurrentFrame].X),
                            Convert.ToInt32(imageMap[CurrentFrame].Y),
                            Convert.ToInt32(this.DisplaySize.X),
                            Convert.ToInt32(this.DisplaySize.Y));
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            
            spriteBatch.Draw(
                this.Texture, 
                new Vector2
                    (
                        this.Rectangle.X, 
                        this.Rectangle.Y
                    ), 
                this.Source, 
                this.Color, 
                this.Rotation, 
                this.Origin, 
                this.Scale, 
                this.SpriteEffect, 
                0
            );            
        }
    }
}
